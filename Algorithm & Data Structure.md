## Algorithm & Data structure

면접에서 실제로 나온 내용은 ⭐️ 처리 하였습니다. 여러번 나오면 여러번 별표를 넣겠습니당! 

##### 1. 버블 정렬에 대해 알려주세요

> 인접한 __두 원소를 비교__하는 알고리즘입니다. 순차적으로 비교해가기 때문에, 마지막 값부터 sorting 됩니다. 간단하지만 시간복잡도가 빅오 엔제곱입니다.

##### 2. 삽입 정렬에 대해 알려주세요.

> 앞에서부터 정렬된 부분과 비교하여, 위치를 삽입하는 방법입니다. 간단하고 정렬이 된 경우에는 빅 오 엔이지만, 평균 최악은 오 엔 제곱입니다. 레코드가 작을때는 가장 강력한 알고리즘입니다. 레코드 수가 많으면 적합하지 않습니다.

##### 3. 선택 정렬에 대해 알려주세요

> N번째 자료를 N+1 ~N-1 까지 비교하여 가장 최솟값을 찾아 swap 하는 기법입니다. 자료 횟수가 미리 정해져있지만, 값이 같은 레코드는 상대적인 위치가 변경됩니다. 최선 최악 평균 다 오의 엔제곱입니다.

##### 4. 합병 정렬에 대해 설명해 주세요.

> merge sort 는 분할 정복 알고리즘 중 하나입니다. 하나의 리스트를 균등한 크기로 분할하고, 부분 리스트를 정렬한 다음 두개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법입니다. 
>
> 안정적인 정렬방법이지만, 머지할 때 임시배열이 필요하고, 레코드들의 크기가 큰 경우에는 이동 횟수가 많아진다는 단점이 있습니다. 링크드리스트를 통해 이동을 줄여줍니다. 시간복잡도는 최고 최악 평균 다 nlogn 입니다. 

##### 5. 퀵 정렬에 대해 설명해 주세요.

> 빠른 수행 속도를 자랑하는 정렬 방법입니다. 분할 정복 알고리즘으로 머지소트와 같지만, 균등하게 분할하는 머지와 다르게 비균등하게 분할한다.  다 정렬된 상태에서 비균등하게 나누어진다면, 최악은 엔제곱이지만, 최선 평균 다 엔로그엔 입니다. 

##### 6. 힙 정렬

> __완전 이진 트리__ 일종으로, 우선순위 큐를 이용하여 만들어진 자료구조. 최댓값 / 최솟값을 쉽게 추출할 수 있습니다. 삽입시에는 마지막 원소에 값을 넣고 정렬합니다. 삭제시에는 자식과 비교하며 더 큰 값과 교환을 합니다. 시간복잡도는 nlogn 입니다. 삽입 삭제는 logn 으로 빠릅니다. 
>
> | Operation                                                    | find-min | delete-min   | insert       | decrease-key | meld     |
> | ------------------------------------------------------------ | -------- | ------------ | ------------ | ------------ | -------- |
> | [Binary](https://en.wikipedia.org/wiki/Binary_heap)[[8\]](https://en.wikipedia.org/wiki/Heap_(data_structure)#cite_note-CLRS-9) | *Θ*(1)   | *Θ*(log *n*) | *O*(log *n*) | *O*(log *n*) | *Θ*(*n*) |
>
> ##### TMI
>
> > 프로그래머스 '더 맵게' 문제를 푼 적이 있다. 문제가 쉬워 금방 풀겠다! 했는데 출제자가 런타임 실행 조건을 적게해서 완전 터져버렸다! 해당 내용은 작은 값 2개를 추출해 더해서 큰 값을 만들어 두는 것이었다. 이 경우, 그냥 sort 를 쓰면 삽입시 O(1), 삭제시 O(N)이 들지만, heap 을 사용하면  삽입 삭제가 logN이당. 이럴때 쓰면 좋다!

##### 7. Stack ⭐️

> Stack 은 선형 자료구조로, LIFO 나중에 들어간 원소가 먼저 나오는 형태입니다. 함수의 콜/스택, 브라우저 뒤로가기에 쓰입니다.

##### 9. Queue ⭐️

> FIFO 구조로 컴퓨터 버퍼에 사용되는 선형 알고리즘입니다.  remove(), is_empty(), peek(), add()로 구성됩니다.Queue 는 먼저 들어간 원소가 먼저 나오는 구조입니다. 컴퓨터 버퍼에 주로 사용됩니다.

##### 10. Heap 

> 완전 이진트리로 만드는 방법으로, 큐에 우선순위 개념을 도입한 알고리즘입니다. 

##### Q. Tree

> 비선형 자료구조로, 계층형 방식을 가집니다. 자식과 노드들로 이루어진 자료구조 형태를 가지고 있습니다. 

##### 11. 이진트리

> 자식 노드의 갯수를 2개 이하로 제한하는 트리입니다.

##### 12. 이진탐색 ⭐️

> 이진 탐색이란 데이터가 정렬돼 있는 배열에서 특정한 값을 찾아내는 알고리즘. 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교한다. X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로, X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색한다. 동일한 방법으로 다시 중간의 값을 임의로 선택하고 비교한다. 해당 값을 찾을 때까지 이 과정을 반복한다
>
> __특징__
>
> 이진 탐색 알고리즘은 정렬된 데이터가 아니면 적용이 불가능하다.
>
> ##### 시간복잡도
>
> logn
>
> ##### 주의
>
> 만약 arr의 크기가 10이라면 9를 right의 매개변수로 전달하는 것이죠. 왜냐면 크기가 10인 배열의 마지막 인덱스는 9이기 때문이죠.

##### 13. Stack vs Queue vs Deque

> Stack 은 선형 자료구조의 일종으로 나중에 들어간 원소가 먼저 나오는 형태입니다. 함수의 콜스택에 쓰입니다. Queue 는 먼저 들어간 원소가 먼저 나오는 구조입니다. 컴퓨터 버퍼에 주로 사용됩니다. Deque 은 자료의 입출력이 양 끝에서 가능하게 하는 자료구조입니다.
>
> ##### 선형자료구조 
>
> 자료를 구성하는 데이터를 순차적으로 나열시킨 형태를 의미한다.

##### 14. Dictionary 와 Array에서 각각의 시간복잡도와 왜 그렇게 생각하는지 ⭐️

> 딕셔너리의 시간 복잡도는 O(1)입니다. 순서가 없고 삭제나 삽입할 때 키 값만 알고있으면 되기 때문입니다.
>
> Array 자료 구조는 찾고자 하는 원소의 인덱스 값을 알고 있다면 BigO(1)에 접근이 가능 합니다. 하지만 삽입과 삭제에서 최악의 시간 복잡도는 O(n)이 됩니다. 삽입과 삭제를 한 후에 원소를 shift 해줘야 하기 때문 입니다.

##### 15. python 에서는 quick 을 쓸까요 merge 를 쓸까요? ⭐️

> python 내부 소트에서 insert + merge 를 쓴다. 그래서 merge 를 쓴다구 대답함. 
>
> timsort 자료
>
> <https://github.com/soomtopia/algorithm-study/blob/master/doc/timsort.md>

##### 16. Tree / Graph 차이를 알려주세요 ⭐️

> 위에 참고

##### 17. BFS / DFS 쓰는 자료구조 형식? 뭐가 더 효율이 안좋은지? ⭐️

> BFS 큐  DFS 스택 
>
> 효율은 에베벱 ㅠㅡㅠ하고 대답한거 기억 안남... 효율은 밑에 적었당

>  깊이가 큰 문제에서는 효율이 굉장히 떨어진다. 모든 경우를 재귀로 탐색할 경우 많은 메모리의 사용(stack overflow 주의)과 탐색시간이 오래 걸린다.

##### 18. Array vs List, 시간복잡도, 구조 차이 ⭐️

> Array 자료 구조는 논리적 저장 순서와 물리적 저장 순서가 일치합니다. 따라서 인덱스로 해당 원소에 접근할 수 있습니다. random access 가 가능한 장점이 있습니다. 찾고자 하는 원소의 인덱스 값을 알고 있다면 BigO(1)에 접근이 가능 합니다. 하지만 삽입과 삭제에서 최악의 시간 복잡도는 O(n)이 됩니다. 삽입과 삭제를 한 후에 원소를 shift 해줘야 하기 때문 입니다.
>
> LinkedList 는 각각의 원소들은 자기 자신 다음에 어떤 원소인지를 기억하고 있는 것입니다. 처음과 마지막 위치에 삽입 또는 삭제를 한다고 하면 O(1)만에 해결이 가능하지만 원하는 위치에서 하고자 하면 O(n)의 시간이 듭니다. 처음 원소부터 위치를 찾아가야하기 때문입니다.

