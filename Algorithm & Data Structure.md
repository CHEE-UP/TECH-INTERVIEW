## Algorithm & Data structure

##### Q. 버블 정렬에 대해 알려주세요

> 인접한 __두 원소를 비교__하는 알고리즘입니다. 순차적으로 비교해가기 때문에, 마지막 값부터 sorting 됩니다. 간단하지만 시간복잡도가 빅오 엔제곱입니다.

##### Q. 삽입 정렬에 대해 알려주세요.

> 앞에서부터 정렬된 부분과 비교하여, 위치를 삽입하는 방법입니다. 간단하고 정렬이 된 경우에는 빅 오 엔이지만, 평균 최악은 오 엔 제곱입니다. 레코드가 작을때는 가장 강력한 알고리즘입니다. 레코드 수가 많으면 적합하지 않습니다.

##### Q. 선택 정렬에 대해 알려주세요

> N번째 자료를 N+1 ~N-1 까지 비교하여 가장 최솟값을 찾아 swap 하는 기법입니다. 자료 횟수가 미리 정해져있지만, 값이 같은 레코드는 상대적인 위치가 변경됩니다. 최선 최악 평균 다 오의 엔제곱입니다.

##### Q. 합병 정렬에 대해 설명해 주세요.

> merge sort 는 분할 정복 알고리즘 중 하나입니다. 하나의 리스트를 균등한 크기로 분할하고, 부분 리스트를 정렬한 다음 두개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법입니다. 
>
> 안정적인 정렬방법이지만, 머지할 때 임시배열이 필요하고, 레코드들의 크기가 큰 경우에는 이동 횟수가 많아진다는 단점이 있습니다. 링크드리스트를 통해 이동을 줄여줍니다. 시간복잡도는 최고 최악 평균 다 nlogn 입니다. 

##### Q. 퀵 정렬에 대해 설명해 주세요.

> 빠른 수행 속도를 자랑하는 정렬 방법입니다. 분할 정복 알고리즘으로 머지소트와 같지만, 균등하게 분할하는 머지와 다르게 비균등하게 분할한다.  다 정렬된 상태에서 비균등하게 나누어진다면, 최악은 엔제곱이지만, 최선 평균 다 엔로그엔 입니다. 

##### Q. 힙 정렬

> __완전 이진 트리__ 일종으로, 우선순위 큐를 이용하여 만들어진 자료구조. 최댓값 / 최솟값을 쉽게 추출할 수 있습니다. 삽입시에는 마지막 원소에 값을 넣고 정렬합니다. 삭제시에는 자식과 비교하며 더 큰 값과 교환을 합니다. 시간복잡도는 nlogn 입니다. 삽입 삭제는 logn 으로 빠릅니다. 
>
> | Operation                                                    | find-min | delete-min   | insert       | decrease-key | meld     |
> | ------------------------------------------------------------ | -------- | ------------ | ------------ | ------------ | -------- |
> | [Binary](https://en.wikipedia.org/wiki/Binary_heap)[[8\]](https://en.wikipedia.org/wiki/Heap_(data_structure)#cite_note-CLRS-9) | *Θ*(1)   | *Θ*(log *n*) | *O*(log *n*) | *O*(log *n*) | *Θ*(*n*) |
>
> ##### TMI
>
> > 프로그래머스 '더 맵게' 문제를 푼 적이 있다. 문제가 쉬워 금방 풀겠다! 했는데 출제자가 런타임 실행 조건을 적게해서 완전 터져버렸다! 해당 내용은 작은 값 2개를 추출해 더해서 큰 값을 만들어 두는 것이었다. 이 경우, 그냥 sort 를 쓰면 삽입시 O(1), 삭제시 O(N)이 들지만, heap 을 사용하면  삽입 삭제가 logN이당. 이럴때 쓰면 좋다!

##### Q. Stack 

> Stack 은 선형 자료구조로, LIFO 나중에 들어간 원소가 먼저 나오는 형태입니다. 함수의 콜/스택, 브라우저 뒤로가기에 쓰입니다.

##### Q. Queue 

> FIFO 구조로 컴퓨터 버퍼에 사용되는 선형 알고리즘입니다.  remove(), is_empty(), peek(), add()로 구성됩니다.Queue 는 먼저 들어간 원소가 먼저 나오는 구조입니다. 컴퓨터 버퍼에 주로 사용됩니다.

##### Q. Heap 

> 완전 이진트리로 만드는 방법으로, 큐에 우선순위 개념을 도입한 알고리즘입니다. 

##### Q. Tree

> 비선형 자료구조로, 계층형 방식을 가집니다. 자식과 노드들로 이루어진 자료구조 형태를 가지고 있습니다. 

##### Q. 이진트리

> 자식 노드의 갯수를 2개 이하로 제한하는 트리입니다.



##### Q. 이진탐색

> 이진 탐색이란 데이터가 정렬돼 있는 배열에서 특정한 값을 찾아내는 알고리즘. 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교한다. X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로, X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색한다. 동일한 방법으로 다시 중간의 값을 임의로 선택하고 비교한다. 해당 값을 찾을 때까지 이 과정을 반복한다
>
> __특징__
>
> 이진 탐색 알고리즘은 정렬된 데이터가 아니면 적용이 불가능하다.
>
> ##### 시간복잡도
>
> logn
>
> ##### 주의
>
> 만약 arr의 크기가 10이라면 9를 right의 매개변수로 전달하는 것이죠. 왜냐면 크기가 10인 배열의 마지막 인덱스는 9이기 때문이죠.

## 나왔던 질문 

##### Q. 스택 / 큐 설명

> 넘 긴장해서 LIFO 인데 RIFO 라고 에베벱거림;; last input first output;; 멀 잘못했느지도 몰랐다 떨려서



##### Q. 퀵 / 머지소트에 대해 설명해주세요

> 위 참고 



##### Q. python 에서는 quick 을 쓸까요 merge 를 쓸까요?

> python 내부 소트에서 insert + merge 를 쓴다. 그래서 merge 를 쓴다구 대답함. 
>
> timsort 자료
>
> <https://github.com/soomtopia/algorithm-study/blob/master/doc/timsort.md>



##### Q. Tree / Graph 차이를 알려주세요

> 위에 참고



##### Q. BFS / DFS 쓰는 자료구조 형식? 뭐가 더 효율이 안좋은지?

> BFS 큐  DFS 스택 
>
> 효율은 에베벱 ㅠㅡㅠ하고 대답한거 기억 안남... 효율은 밑에 적었당

>  깊이가 큰 문제에서는 효율이 굉장히 떨어진다. 모든 경우를 재귀로 탐색할 경우 많은 메모리의 사용(stack overflow 주의)과 탐색시간이 오래 걸린다.



##### Q. 이진탐색에서 잘 발생해서 조심해야하는 문제가 있다. 이게 무엇이냐!? 기억이 안나면 손코딩을 해봐라!

> 에베벱 ㅠㅡㅠ 함.. 시간복잡도, 주의해야할 점, 을 잘 몰라서 손코딩해보라했는데 완전 에베베벱...시간복잡도도 log n 같지만 왠지 nlogn 으로 나오는 친구들이많아서 nlogn 이라거하거....에베베베벱...ㅠ0ㅠ
>
> 그래도 정렬이 되어있어야 한다는 상태를 안다고 위로해주심..
>
> 주의할점, 시간복잡도, 탐색 개념 알기! 
>
> 개념은 위에 참고 